# 实时位置更新优化 - 说明文档

**日期**: 2026-01-08  
**改进内容**: 优化 beacon 和 anchor（小车）位置的实时更新机制

---

## 🎯 改进目标

确保 beacon 和 anchor 位置能够**实时、独立地更新**到地图上，无论哪个数据源更新，都能立即反映在地图显示中。

---

## ❌ 之前的问题

### 更新逻辑缺陷

1. **Beacon 更新依赖 tracked_pose**
   - AOA 数据更新时，只保存局部坐标
   - 必须等到收到 `/tracked_pose` 时才重新计算全局坐标
   - 如果小车不动，beacon 位置变化也不会在地图上更新

2. **重复的更新代码**
   - beacon 全局坐标计算逻辑分散在多处
   - 不易维护和调试

3. **更新时机不合理**
   - 两个独立的数据源互相依赖
   - 无法实现真正的实时更新

---

## ✅ 优化方案

### 1. 统一的更新方法

新增 `_update_beacon_global_position()` 方法：

```python
def _update_beacon_global_position(self):
    """
    根据最新的 beacon 局部坐标和小车位置，计算并更新 beacon 全局坐标
    这个方法会在以下情况被调用：
    1. 收到新的 AOA 数据（beacon 局部坐标更新）
    2. 收到新的 tracked_pose 数据（小车位置更新）
    """
```

**功能**:
- 检查是否有必要的数据（beacon 局部坐标 + 小车位置）
- 计算 beacon 全局坐标
- 更新地图显示（对话框和选项卡）
- 发布 `/globe_beacon` 话题

### 2. 实时更新触发

#### AOA 数据更新时

```python
def _on_aoa_frame_received(self, frame_info: dict):
    # ... 保存滤波坐标 ...
    
    # ✨ 新增：立即重新计算并更新 beacon 全局坐标
    self._update_beacon_global_position()
```

**效果**: 每次收到新的 AOA 数据，beacon 位置就会立即更新到地图上（前提是已有小车位置）

#### Tracked Pose 更新时

```python
def _on_topic_message_ui(self, topic: str, payload):
    if topic == "/tracked_pose":
        # 保存最新的小车位置
        self.latest_tracked_pose = pose_data
        
        # ✨ 重新计算并更新 beacon 全局坐标
        self._update_beacon_global_position()
        
        # ✨ 实时更新地图中的小车位置
        if self.map_viewer_dialog:
            self.map_viewer_dialog.update_tracked_pose(pose_data)
        if self.map_viewer_widget:
            self.map_viewer_widget.update_tracked_pose(pose_data)
```

**效果**: 每次收到新的小车位置，地图上的小车标注和 beacon 位置都会更新

### 3. 新增状态保存

```python
self.latest_tracked_pose = None  # 保存最新的小车位置
```

**作用**: 
- 使 beacon 全局坐标计算能够使用最新的小车位置
- 即使 AOA 数据单独更新，也能正确计算全局坐标

---

## 📊 更新机制对比

### 之前的机制

```
AOA 数据更新 → 保存局部坐标 → ❌ 不更新地图
                                ↓ (等待)
tracked_pose 更新 → 计算全局坐标 → ✅ 更新地图
```

**问题**: 如果小车静止，beacon 移动时地图不更新

### 优化后的机制

```
AOA 数据更新 → 保存局部坐标 → 立即调用 _update_beacon_global_position()
                                ↓
                          计算全局坐标 + 更新地图 ✅

tracked_pose 更新 → 保存位置 → 立即调用 _update_beacon_global_position()
                                ↓
                          更新小车位置 + 重新计算 beacon + 更新地图 ✅
```

**优势**: 
- ✅ 两个数据源独立更新
- ✅ 任一数据变化都会实时反映在地图上
- ✅ 代码更简洁，逻辑更清晰

---

## 🔄 更新流程图

### Beacon 位置更新流程

```
┌─────────────────────┐
│  收到 AOA 数据      │
│  (beacon 局部坐标)  │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ 保存到              │
│ latest_filtered_    │
│ beacon              │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ _update_beacon_     │
│ global_position()   │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│ 有小车位置数据？    │────→│  NO: 返回，等待     │
└──────────┬──────────┘     └─────────────────────┘
           │ YES
           ▼
┌─────────────────────┐
│ 计算全局坐标        │
│ (transform_local_   │
│ to_global)          │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ 更新地图显示        │
│ - Dialog (如果打开) │
│ - Widget            │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ 发布 /globe_beacon  │
└─────────────────────┘
```

### Anchor（小车）位置更新流程

```
┌─────────────────────┐
│  收到 tracked_pose  │
│  (小车全局位置)     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ 保存到              │
│ latest_tracked_pose │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ _update_beacon_     │
│ global_position()   │ ← 重新计算 beacon 全局坐标
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ 更新地图中的        │
│ 小车位置显示        │
│ - Dialog            │
│ - Widget            │
└─────────────────────┘
```

---

## 🧪 测试场景

### 场景1: Beacon 移动，小车静止

**步骤**:
1. 小车位置固定不变（不发送 `/tracked_pose`）
2. AOA 持续接收新数据（beacon 位置变化）

**预期结果**:
- ✅ 地图上的 beacon 红点位置持续更新
- ✅ 小车蓝色箭头保持不变

### 场景2: 小车移动，Beacon 相对位置不变

**步骤**:
1. AOA 数据保持不变（beacon 局部坐标固定）
2. 小车持续移动（发送新的 `/tracked_pose`）

**预期结果**:
- ✅ 地图上的小车箭头位置持续更新
- ✅ Beacon 红点随小车移动（全局坐标重新计算）

### 场景3: 两者同时移动

**步骤**:
1. AOA 数据持续更新
2. 小车持续移动

**预期结果**:
- ✅ 小车和 beacon 位置都实时更新
- ✅ 更新平滑，无闪烁或延迟

---

## 📝 代码修改清单

### 修改的文件

- ✅ `ui/main_window.py`

### 主要改动

1. **新增属性**
   ```python
   self.latest_tracked_pose = None  # 保存最新的小车位置
   ```

2. **新增方法**
   ```python
   def _update_beacon_global_position(self):
       """统一的 beacon 全局坐标更新方法"""
   ```

3. **修改方法**
   - `_on_aoa_frame_received()` - 添加实时更新调用
   - `_on_topic_message_ui()` - 简化更新逻辑
   - `_publish_globe_beacon()` - 修复日志输出 bug

---

## 🚀 使用方法

### 无需额外配置

优化后的代码**自动工作**，无需任何配置更改。

### 观察实时更新

启动应用后：

```bash
python main.py
```

**观察要点**:
1. 打开地图查看器（点击"📍 显示实时地图"按钮）
2. 观察终端日志：
   ```
   🔄 Beacon全局位置已更新: (3.45, 2.10)m
   🗺️ 更新对话框中的beacon位置
   🗺️ 更新选项卡中的beacon位置
   ```
3. 观察地图上的标注：
   - 🔵 蓝色箭头（小车）实时移动
   - 🔴 红色圆点（beacon）实时移动

---

## 💡 技术细节

### 更新频率

- **AOA 数据**: 通常 10-50 Hz（取决于串口波特率和数据率）
- **Tracked Pose**: 通常 10-20 Hz（取决于 WebSocket 发布频率）
- **地图刷新**: 跟随数据更新频率，实时响应

### 性能优化

1. **条件检查**: 只在有必要数据时才计算
2. **局部变量**: 避免重复访问字典
3. **日志级别**: 使用 DEBUG 级别避免影响性能

### 线程安全

- 所有 UI 更新通过 Qt 信号机制（`pyqtSignal`）
- WebSocket 数据通过 `_topic_relay` 转发到主线程
- 无需额外的线程锁

---

## 🐛 故障排除

### 问题: Beacon 位置不更新

**检查**:
1. 是否收到 AOA 数据？
   ```
   保存最新滤波坐标: x=1.234, y=5.678
   ```
2. 是否有小车位置数据？
   ```
   AMR位置: (2.50, 1.30)m
   ```

**解决**: 确保两个数据源都正常

### 问题: 小车位置不更新

**检查**:
1. WebSocket 是否连接？
2. 是否订阅了 `/tracked_pose` 话题？
3. 检查 `topics.txt` 文件

---

## 📖 相关文档

- [小车位置显示问题_修复完成报告.md](小车位置显示问题_修复完成报告.md) - 边界检查修复
- [小车位置显示_快速参考.md](小车位置显示_快速参考.md) - 快速参考指南
- [GLOBE_BEACON_实现总结.md](GLOBE_BEACON_实现总结.md) - Beacon 坐标系统

---

## ✨ 总结

本次优化通过引入**统一的更新方法**和**保存最新状态**，实现了：

✅ **真正的实时更新** - 任一数据源变化都会立即反映  
✅ **独立的更新机制** - 两个数据源互不依赖  
✅ **代码更简洁** - 消除重复逻辑  
✅ **更好的可维护性** - 集中管理更新逻辑  

现在，beacon 和 anchor 的位置可以**独立、实时地**在地图上更新，提供更流畅的用户体验！

---

**优化完成时间**: 2026-01-08
